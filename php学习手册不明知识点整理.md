如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致PHP开始输出这些空白，而脚本中此时并无输出的意图。--不推荐使用这将如预期中的运行，因为当 PHP 解释器碰到 ?> 结束标记时就简单地将其后内容原样输出（除非马上紧接换行见指令分隔符）直到碰到下一个开始标记；例外是处于条件语句中间时，此时PHP解释器会根据条件判断来决定哪些输出，哪些跳过。见下例。可以在 PHP 中使用四对不同的开始和结束标记。其中两种，<?php ?> 和 <script language="php"> </script> 总是可用的。另两种是短标记和 ASP 风格标记，可以在 php.ini 配置文件中打开或关闭。尽管有些人觉得短标记和 ASP 风格标记很方便，但移植性较差，通常不推荐使用。文件末尾的 PHP 代码段结束标记可以不要，有些情况下当使用 include 或者 require 时省略掉会更好些，这样不期望的空白符就不会出现在文件末尾，之后仍然可以输出响应标头。在使用输出缓冲时也很便利，就不会看到由包含文件生成的不期望的空白符。
如果只是想得到一个易读懂的类型的表达方式即名称用于调试，用 gettype() 函数。要查看某个类型，不要用 gettype() ，而用 is_type 类函数。如果要将一个变量强制转换为某类型，可以对其使用强制转换或者 settype() 函数。
-为什么使用 $_GET？
注释：在使用 $_GET 变量时，所有的变量名和值都会显示在 URL 中。所以在发送密码或其他敏感信息时，不应该使用这个方法。不过，正因为变量显示在 URL 中，因此可以在收藏夹中收藏该页面。在某些情况下，这是很有用的。
注释：HTTP GET 方法不适合大型的变量值；值是不能超过 100 个字符的。
-为什么使用 $_POST？
通过 HTTP POST 发送的变量不会显示在 URL 中。 
变量没有长度限制。 
不过，由于变量不显示在 URL 中，所有无法把页面加入书签。
-$_REQUEST 变量
PHP 的 $_REQUEST 变量包含了 $_GET, $_POST 以及 $_COOKIE 的内容。
PHP 的 $_REQUEST 变量可用来取得通过 GET 和 POST 方法发送的表单数据的结果。











指定一个布尔值，使用关键字 TRUE 或 FALSE 。两个都不区分大小写。
当转换为 boolean 时，以下值被认为是 FALSE ： 
•   布尔值 FALSE 本身 
•   整型值 0（零） 
•   浮点型值 0.0（零） 
•   空字符串，以及字符串 "0" 
•   不包括任何元素的数组 
•   不包括任何成员变量的对象（仅 PHP 4.0 适用） 
•   特殊类型 NULL（包括尚未赋值的变量） 
•   从空标记生成的 SimpleXML 对象 
所有其它值都被认为是 TRUE （包括任何资源）。 
   要使用八进制表达，数字前必须加上 0（零）。要使用十六进制表达，数字前必须加上 0x。要使用二进制表达，数字前必须加上 0b。
###字符串String
 #表示方法：单引号、双引号、heredoc和nowdoc格式
   Heredoc类似双引号字符串结构，特殊字符转义，变量解析
   Nowdoc类似单引号字符串结构
   error_reporting(E_ALL);显示所有的错误
   echo "This is {$arr['key']}";在双引号字符串中使用数组键值时，要加上花括号
   字符串也可以用下标查找：$str="fantastic";
 #echo $str[2];也可以使用$str{2}
 #strlen($str)获取字符串的长度
 #$str[2]="z";修改了原字符串相应位置的值
 #(string)(123);将123转换为字符串 或使用字符串转换函数:strval()
 #serialize();  unserialize();
 #ord();chr()字符换的ascii码转换

###数组

 #php5.4后可以使用[]代替array()定义数组，最后一个会覆盖前面的同名索引对应的值
 #方括号[]和花括号{}可以互换使用
 #unset()删除某键值对，也可以删除整个数组
 #array_values()对数组进行重新索引编号，从0开始
 #引用数组时，用不着给键名为常量和变量德的加上引号，否则php不能解析，如$arr[$var]
 #count($arr)计算数组的长度
 #实现数组遍历使用foreach函数
    foreach ($variable as $key => $value) {
      # code...
    }
 #数组排序 sort(),返回布尔值，对原数组进行了修改
 #array_map()对数组元素分别应用方法

###object 
 
###NULL（包括尚未赋值的变量）
 #一个变量被认为是null：不区分大小写
    1、被复值为null
    2、尚未被赋值
    3、被unset()
 #判断：is_null()
 #



###变量
-变量名区分大小写
-一般是传值赋值，也可使用关键&引用赋值
-isset()检测一个变量是否已经被初始化
-PHP全局变量在函数中使用时必须声明为global，否则不可用
   $a=1;
   function test(){
        echo $a;
   }
   test();//不会输出任何值
-也可以使用全局数组$GLOBALS来访问全局变量
-静态局部变量：仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失
    function test(){
        static $a=0;
        echo $a;
        $a++;
    }//$a仅在第一次调用函数时初始化
-可变变量 
    $a='hello';
    $$a='world';等价于$hello='world';
*常量：
    -对大小写敏感，但一般大写
    -defined()检测是否定义了某个常量
    -常量只能用define()定义
*魔术常量
    -__LINE__
    -__FILE__
    -__DIR__
    -__FUNCTION__
    -__CLASS__
    -__TRAIT__
    -__METHOD__
    -__NAMESPACE__
*表达式
**运算符
    -PHP在对象赋值时是引用赋值的
    -两个浮点数比应该被比较
**错误控制符@
    -放在一个表达式之前，屏蔽表达式产生的错误
**执行运算符
    -反引号``,效果与shell_exec()函数相同
**递增递减运算符
    -可以对字符变量使用递增递减，即$a='a'; $a++,按照ascii码计算
**逻辑运算符
    -与：and     &&   &&优先级更高
    -或：or      ||   ||优先级更高
    -非：!
    -异或： xor
**数组运算符
    -+将两个数组连接成一个数组，保留左边的同名元素，右边的被覆盖
    -$a==$b 如果两个数组有相同的键值对，则返回true
    -$a===$b 如果两个数组有相同的键值对，而且顺序和类型都相同，则返回true
**类型运算符instanceof，用于确定一个变量是否属于某一类class的实例
    -var_dump($a instanceof MyClass);
    -也可以确定某一个变量是否是集成子一个父类的子类
    -还可以确定一个变量是否实现了某个接口的对象的实例

##流程控制
**流程控制的替代语法
    -PHP提供了一些流程控制的替代语法，包括if\while\for\foreach\和switch，替代的方法是：将左花口号换成冒号:,把右花括号换成endif;\endwhile\endfor\endforeach\endswitch
    -foreach仅能够应用于数组和对象
     foreach可以引用赋值
     foreach($arr as $key => &$value),一般在不用时要取消引用unset($value)
    -foreach不支持@抑制错误信息
**list()将嵌套的数组解包
**break可以接受一个可选的参数来决定跳出几重循环，默认为1
**switch做的是松散的比较
    -switch仅求值一次，而在elseif语句中每次比较都要重新求值
**declare结构
**不是所有的语句都可以计时，条件表达式和参数参数表达式都不可以计时
**include 和require
**goto函数
    -goto a;
     echo 'foo';
     a:
     echo 'bar';
**函数
    -函数名是小写无关的
    -php默认按值传递参数，引用传递和默认参数
    -匿名函数

#类与对象
**每个变量都持有对象的引用，而不是整个对象的拷贝
**对象和实例，对象是对实例的引用，通过克隆的方法可以给已经创建对象的实例建立一个新的实例
    -子类继承父类，重写方法时要把保持参数一致，但构造函数除外
    -::class
**类常量
    -使用const关键字可以定义常量,不要加$
        const aa='haha';
    -调用类常量时，使用self关键字，不要加$,self::aa;(在类内部调用)，在类外部调用可以直接使用类名或对象名::aa；
**自动加载类，__autoload()函数,未来可能被启用，改用spl_autoload_register()函数。
**命名空间
**访问控制
    -public protected private
**范围解析操作符::,可以用来访问静态变量和类常量，在类外使用这些属性和方法时要带类名
    -self\parent\static是用于在类定义内部对其属性或方法进行访问的
**static关键字
    -静态属性不能通过一个类实例化的对象来访问，但静态方法可以
**抽象类、抽象方法
    -被声明了抽象的方法只是声明了器调用方式（参数），不能定义其具体的功能实现，介于接口和类之间
    -继承一个抽象类时，必须定义父类中的所有抽象方法，访问控制至少更为宽松，参数设置必须一致（必须含有父类中的参数，可以添加可选的参数）
**接口
    -接口中定义的所有方法都必须是公有的
    -接口中的方法都是只声明不定义
    -类继承接口要实现接口中所有声明方法的定义，形式参数也要一致
    -类可以实现多个接口，用逗号分隔，但不可以继承多个类
    -接口也可以继承
    -接口也可以定义常量，但不能被子类或子接口覆盖
**traits
    -调用关键字：use Traitsname
    -优先级：子类成员覆盖trait中定义的方法，trait覆盖父类中的方法
    -通过逗号分隔，在use声明列出多个trait,可以都插入到一个类中
    -解决冲突insteadof关键字和as关键字
    -as关键字也可以修改trait被引入的访问控制
    -triat可以组合，在一个trait中use多个trait
    -trait可以声明抽象方法
    -trait中可以定义静态属性和静态方法
    -trait中可以定义属性，但类中不能定义同名属性，否则出错
**重载：通过魔术方法实现
    -__set() __get() __isset() __unset() 当对不可访问的属性操作时会调用相应的方法
    -__call()  __callStatic()  当对不可访问的方法或静态方法操作时会调用相应的方法
**遍历对象
    -可以使用foreach语句，默认情况下，所有可见属性都将被用于遍历
**魔术方法
    -__construct() __destruct() __call()  __callStatic()  __get()
    __set() __isset() __unset()  __sleep() __wakeup() __toString()
    __ invoke() __set_state()  __clone()
**final
    -属性不能被定义为final,只有类和方法才能被定义为fianl
**对象复制
    -通过clone关键字，这将调用新生成的对象中的__clone()方法修改属性的值,对象中的__clone()方法不能被直接调用，但所有的引用属性仍然会是指向原来的变量的引用
**对象的比较
    -==原则是：如果两个对象的属性和属性值都相等，而且两个对象是同一个类的实例，那么这两个对象相等；===原则是：这两个对象变量一定要指向某个类的同一个实例（即同一个对象）
**类型约束
    -类中方法的参数可以指定必须为某一类型
    -函数中也可以指定参数的类型
**后期静态绑定


#正则表达式

preg_quote("*\()[]") 将字符串转换为正则表达式（不包括定界符//）

\h 任意水平空白字符(since PHP 5.2.4) 
\H 任意非水平空白字符(since PHP 5.2.4) 
\V 任意非垂直空白字符(since PHP 5.2.4) 
\w 任意单词字符  单词字符指的是任意字母、数字、下划线
W 任意非单词字符 

###断言。 一个断言指定一个必须在特定位置匹配的条件， 它们不会从目标字符串中消耗任何字符。
反斜线断言包括： 
\b 单词边界 
\B 非单词边界 
这些断言不能出现在字符类中(但是注意， “\b”在字符类中有不同的意义， 表示的是退格(backspace)字符)    []叫做字符类

\A， \Z， \z断言不同于传统的^和$(详见下文)， 因为他们永远匹配目标字符串的开始和结尾，而不会受模式修饰符的限制。












